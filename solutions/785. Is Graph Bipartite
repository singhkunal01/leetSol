class Solution {
bool bipartiteBFS(int node,vector<vector<int>>& graph,vector<int> &color){
    int sz = graph.size();
    queue<int> ds({node});
    color[node] = 1;
    while (!ds.empty()) {
        int currNode = ds.front(); ds.pop();
        for (int i = 0;i<graph[currNode].size();i++) {
            if (color[graph[currNode][i]] == -1) {
                color[graph[currNode][i]] = 1 - color[currNode];
                ds.push(graph[currNode][i]);
            }
            //else if check whether the adjacents of current node having same color or not if not then return false'
            else if (color[graph[currNode][i]] == color[currNode])
                return false;
        }
    }
​
    return true;
}
public:
    bool isBipartite(vector<vector<int>>& graph) {
        int n = graph.size();
            vector<int> color(n, -1);
//for multiple components
    for (int i = 0; i < n; i++) {
        if (color[i] == -1) {
//check for the bipartite
            if (!bipartiteBFS(i, graph, color)) return false;
        }
    }
    return true;
    }
};
